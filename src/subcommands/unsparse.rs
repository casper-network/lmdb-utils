use std::{
    fs,
    io::Error as IoError,
    path::{Path, PathBuf},
};

use clap::{Arg, ArgMatches, Command};
use lmdb::{Environment, EnvironmentFlags, Error as LmdbError};
use log::{error, info};
use thiserror::Error as ThisError;

pub const COMMAND_NAME: &str = "unsparse";
const DB_PATH: &str = "file-path";

#[derive(ThisError, Debug)]
pub enum Error {
    #[error("Failed to get metadata for {0}: {1}")]
    Metadata(PathBuf, IoError),
    #[error("Failed to open lmdb database at {0}: {1}")]
    Lmdb(PathBuf, LmdbError),
    #[error("Failed to reduce size of {0} from {1} bytes")]
    Size(PathBuf, u64),
}

pub fn command(display_order: usize) -> Command<'static> {
    Command::new(COMMAND_NAME)
        .display_order(display_order)
        .about(
            "Reduces the disk size of an LMDB database generated by a Casper node by removing \
            empty blocks of the sparse file.",
        )
        .arg(
            Arg::new(DB_PATH)
                .display_order(0)
                .value_name("DB_PATH")
                .required(true)
                .help("Path to the storage.lmdb or data.lmdb file."),
        )
}

pub fn run(matches: &ArgMatches) -> Result<(), Error> {
    let path = Path::new(
        matches
            .value_of(DB_PATH)
            .expect("should have file-path arg"),
    );
    unsparse(path)
}

fn unsparse(path: &Path) -> Result<(), Error> {
    let size_before = fs::metadata(path)
        .map(|metadata| metadata.len())
        .map_err(|io_err| Error::Metadata(path.to_path_buf(), io_err))?;

    let _env = Environment::new()
        .set_flags(EnvironmentFlags::WRITE_MAP | EnvironmentFlags::NO_SUB_DIR)
        .set_max_dbs(100)
        .set_map_size(1)
        .open(path)
        .map_err(|lmdb_err| Error::Lmdb(path.to_path_buf(), lmdb_err))?;

    let size_after = fs::metadata(path)
        .map(|metadata| metadata.len())
        .map_err(|io_err| Error::Metadata(path.to_path_buf(), io_err))?;

    if size_before > size_after {
        info!(
            "Reduced size of {} from {} to {} bytes.",
            path.display(),
            size_before,
            size_after
        );
        Ok(())
    } else {
        error!(
            "Failed to reduce size of {} from {} bytes.",
            path.display(),
            size_before
        );
        Err(Error::Size(path.to_path_buf(), size_before))
    }
}

#[cfg(test)]
mod tests {
    use casper_storage::block_store::{BlockStoreProvider, BlockStoreTransaction, DataWriter};
    use casper_types::{testing::TestRng, Block, TestBlockBuilder};

    use super::*;
    use crate::{common::db::STORAGE_FILE_NAME, test_utils::LmdbTestFixture};

    #[test]
    fn should_reduce_lmdb_file_size() {
        let mut rng = TestRng::new();
        let mut fixture = LmdbTestFixture::new();
        let block: Block = TestBlockBuilder::new().build(&mut rng).into();
        let mut rw_txn = fixture.block_store.checkout_rw().unwrap();
        let _ = rw_txn.write(&block).unwrap();
        rw_txn.commit().unwrap();

        let db_path = fixture.tmp_dir.path().join(STORAGE_FILE_NAME);
        let db_size = || {
            fs::metadata(db_path.as_path())
                .unwrap_or_else(|error| {
                    panic!("should get metadata for {}: {}", db_path.display(), error)
                })
                .len()
        };
        let size_before = db_size();
        unsparse(db_path.as_path()).expect("unsparse should succeed");
        let size_after = db_size();
        assert!(size_after < size_before, "unsparse should reduce file size");

        assert!(unsparse(&db_path).is_err(), "repeat unsparse should fail");
        assert_eq!(db_size(), size_after, "file size should be unchanged");
    }
}
